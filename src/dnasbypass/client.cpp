#include <unistd.h>
#include <iostream>
#include <iomanip>
#include <map>
#include <openssl/sha.h>

#include <logger.h>
#include <server.h>
#include <globals.h>
#include <util.h>
#include <atomizes.hpp>
#include <dnasbypass/dnas.h>

#include <dnasbypass/client.h>

using namespace atomizes;


//
// Game: Battlefield 2: Modern Combat (us)
//
/*
	On "v2.5_i-connect" request.
	
	This is what the ps2 sends as a file. This file content is used as a kind of ?challenge?.
*/
std::vector<unsigned char> example_A_packet1 =
{
	// Query type
	0x01, 0x18, 0x00, 0x00,
	
	// ? Unknown ?
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x0c, 0x00, 0x02, 0x00, 0x05,
	
	// Game ID: This value can be found in the game files
	0xca, 0x08, 0x10, 0x76, 0x7e, 0x46, 0x1a, 0x49,
	
	// Random data
	0x10, 0xa0, 0x5d, 0xdd, 0x78, 0xcc, 0x6c, 0x07, 0x08, 0xb9, 0xbf, 0xd9, 0x6e, 0x52, 0x5f, 0x61,
	0xc0, 0xd2, 0x10, 0x3b, 0x35, 0x73, 0xea, 0xb8, 0x30, 0xaa, 0x2e, 0x55, 0x96, 0x99, 0x62, 0xc0,
	0x8e, 0x3f, 0x6d, 0x3f, 0xfb, 0xb7, 0x37, 0xd6, 0xf9, 0x1e, 0x29, 0xa5, 0x82, 0xe1, 0xb3, 0x86,
	0x4f, 0x91, 0x22, 0xb5, 0x88, 0xe5, 0x8a, 0x67, 0x16, 0xd1, 0x52, 0xcf, 0x5e, 0xea, 0xa9, 0x53,
	0xc4, 0x52, 0x7b, 0x1f, 0x29, 0x0b, 0x12, 0x6f, 0x2d, 0xa7, 0xe5, 0x18, 0x56, 0xea, 0x68, 0x14,
	0x93, 0x37, 0x9c, 0x76, 0x40, 0x74, 0x05, 0x5c, 0x77, 0xd6, 0x9a, 0xa2, 0xd4, 0x8e, 0x54, 0x54,
	0xc2, 0xea, 0x43, 0x5d, 0xf8, 0xa9, 0xd6, 0xf0, 0x72, 0x5e, 0xeb, 0xa6, 0xfd, 0xd0, 0xbc, 0x38,
	0xf1, 0x6d, 0xe6, 0x56, 0x39, 0x29, 0x1d, 0xa3, 0x0c, 0xd8, 0x41, 0x48, 0x9c, 0xda, 0x49, 0xfb,
	0x50, 0xdc, 0x59, 0x95, 0xfd, 0x32, 0x48, 0x7e, 0x16, 0x22, 0xb5, 0x40, 0xa9, 0xab, 0x75, 0x23,
	0x68, 0xa9, 0xe6, 0x46, 0xcb, 0x82, 0x01, 0x48, 0x0d, 0x96, 0x58, 0xa9, 0x23, 0x50, 0xb3, 0xad,
	0xf3, 0x45, 0x43, 0xca, 0x32, 0x41, 0x6a, 0xc1, 0x2c, 0x5c, 0xae, 0x15, 0x46, 0x4c, 0xc8, 0xb3,
	0x8f, 0xb8, 0xe7, 0xee, 0x8c, 0x8d, 0x88, 0xd3, 0xce, 0xbe, 0x25, 0xfb, 0xef, 0x77, 0x2c, 0x1f,
	0xbe, 0xd9, 0xda, 0x5a, 0x5a, 0x1d, 0x54, 0x22, 0xda, 0xfd, 0xb2, 0xbd, 0x2b, 0x07, 0x85, 0xec,
	0xa7, 0x6f, 0x37, 0x3c, 0x5f, 0x3b, 0x5d, 0x51, 0x3f, 0xf5, 0x6c, 0xa4, 0x6d, 0xda, 0x63, 0x91,
	0x8d, 0x38, 0x49, 0x68, 0x76, 0xba, 0xbf, 0xa7, 0x7e, 0x55, 0x4e, 0x74, 0x5a, 0x13, 0xc0, 0xbb,
	0xe6, 0x3b, 0x63, 0xae, 0x24, 0x6f, 0x54, 0x17, 0xb9, 0x66, 0xf1, 0xcd, 0xc9, 0x12, 0x34, 0x95
};

/*
	On "v2.5_i-connect" response.
	
	This is what the server sends as file as a signature to proves himself.
	
	File name: ca0810767e461a49_01180000
*/
std::vector<unsigned char> example_A_packet2 =
{
	// Query type
	0x01, 0x18, 0x00, 0x05,
	
	// * Can be disabled for first request but needs it for second other request
	0x01, 0x0e, 0x5c, 0x55, 0x17, 0x38, 0x16, 0x12, 0x09, 0x07, 0xe0, 0x00, 0x00, 0x33, 0xa8, 0x00,
	0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x8c, 0xb3, 0x8e, 0x6d, 0x07, 0x6d, 0x27, 0x5d, 0xdf,
	
	// Looks like a static value that never change
	0x00, 0x00, 0x01, 0x20,
	
	// Can be disabled...
	//0xd0, 0xdc, 0x99, 0x19, 0xf1, 0x1e, 0x42, 0x85, 0x9a, 0xe1, 0xaa, 0x19, 0x3c, 0x08, 0x35, 0x84,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x7d, 0xc7, 0x57, 0x3a, 0xd3, 0xe2, 0x7a, 0x54, 0x1d, 0x75, 0x0b, 0xf6, 0xfc, 0x52, 0x12, 0x32,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	
	// *
	0x3a, 0x6c, 0xde, 0xa9, 0x7e, 0x33, 0x8a, 0x6d, 0x04, 0x93, 0xe3, 0x30, 0xdb, 0x59, 0x7c, 0x91,
	0x47, 0x10, 0xec, 0x17, 0x56, 0xbd, 0xa5, 0x52, 0x87, 0x79, 0x3d, 0x99, 0x0b, 0x79, 0x03, 0x46,
	0xaf, 0x0f, 0x04, 0x5e, 0x47, 0x1f, 0x4f, 0x9b, 0xdd, 0xd8, 0x33, 0x72, 0x29, 0x4b, 0x42, 0xce,
	0x06, 0x5c, 0x6e, 0x52, 0x21, 0xde, 0xc7, 0xa0, 0x54, 0x56, 0xac, 0xed, 0xdf, 0x7e, 0x4a, 0xde,
	0xb3, 0x4d, 0x0b, 0xab, 0x5c, 0x9e, 0x55, 0xe8, 0xfc, 0x17, 0x36, 0xd6, 0xd2, 0x61, 0xba, 0xa5,
	0xb1, 0xd5, 0xd2, 0x4a, 0x09, 0x45, 0x06, 0x31, 0x81, 0x81, 0xdb, 0xda, 0x57, 0xe6, 0xcc, 0xbe,
	0x8e, 0x1a, 0x8e, 0x01, 0x3c, 0xde, 0x2e, 0x53, 0x9d, 0x08, 0xfb, 0x78, 0x14, 0x27, 0xb4, 0xe9,
	0xfb, 0xd9, 0xf1, 0x10, 0x6b, 0x75, 0xe9, 0xc0, 0xbf, 0x6d, 0xf9, 0xd7, 0x7f, 0x44, 0x4d, 0x55,
	0xe0, 0x80, 0x76, 0x4e, 0xf5, 0xc1, 0x0c, 0x97, 0x36, 0xd6, 0xe3, 0xe9, 0x4c, 0x23, 0x02, 0x2f,
	0x4f, 0x09, 0xe0, 0xb7, 0xc6, 0x14, 0xc2, 0x40, 0x9a, 0x79, 0xa3, 0x5c, 0xd7, 0xc4, 0xb7, 0xb7,
	
	// Can be disabled...
	//0x84, 0x7a, 0xf5, 0xf3, 0xe3, 0x04, 0x14, 0xcc, 0x81, 0x3f, 0xf6, 0x74, 0x31, 0xc1, 0xc2, 0xca,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0xd3, 0xa7, 0xcf, 0x34, 0x34, 0xb0, 0x65, 0x2f, 0x5b, 0xad, 0xb9, 0x45, 0x55, 0xd2, 0x33, 0xda,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x4c, 0xFF, 0xcd, 0x2f, 0x2e, 0xe2, 0xfc, 0xaf, 0x21, 0xf2, 0x23, 0x53, 0xb4, 0xe6, 0x1d, 0x88,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x8d, 0xec, 0xbd, 0xc2, 0x9d, 0x22, 0xf1, 0xf8, 0xd0, 0xab, 0x3e, 0x26, 0x7d, 0x71, 0x00, 0xc9,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x9b, 0xce, 0xf9, 0xc9, 0xb0, 0xf5, 0x78, 0xd2, 0xe8, 0x9c, 0x25, 0x9c, 0x82, 0x42, 0x25, 0x10,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x2e, 0xe2, 0xd2, 0xcb, 0x04, 0xc3, 0xc4, 0xd5, 0x6e, 0x02, 0xfc, 0xeb, 0x74, 0xfc, 0xb5, 0x10,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

/*
	On "v2.5_others" request.
	
	This is what the ps2 sends as a file. This file content is used as a kind of ?challenge?.
*/
std::vector<unsigned char> example_A_other_packet1 =
{
	// Query type
	0x01, 0x18, 0x80, 0x01,
	
	// Unknown
	0x01, 0x0e, 0x5c, 0x55, 0x17, 0x38, 0x16, 0x12, 0x09, 0x07, 0xe0, 0x00, 0x00, 0x33, 0xa8, 0x00,
	0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00,
	
	// Response ID 
	0x8c, 0xb3, 0x8e, 0x6d, 0x07, 0x6d, 0x27, 0x5d,
	
	// Unknown
	0xdf, 0x00, 0x00, 0x00, 0x90, 0xcb, 0x20, 0x6e, 0x6c, 0x79, 0x07, 0xf2, 0x84, 0xed, 0x87, 0x6f,
	0x72, 0x0b, 0xa1, 0x57, 0x72, 0xd3, 0x5e, 0x2e, 0x32, 0xfa, 0xfc, 0x50, 0x14, 0x96, 0x2d, 0xe4,
	0x1b, 0x70, 0x03, 0x0d, 0xdc, 0x71, 0x2e, 0xa7, 0xf6, 0x20, 0xaf, 0x70, 0x92, 0x1e, 0xf8, 0x80,
	0x91, 0x4f, 0x21, 0x9c, 0x23, 0x80, 0xcb, 0x56, 0x7a, 0xc7, 0xa6, 0x8e, 0x5e, 0xd4, 0x73, 0x79,
	0x44, 0x76, 0x86, 0x20, 0xe8, 0xb4, 0xc8, 0xdf, 0xd4, 0x77, 0x4f, 0x67, 0x95, 0x47, 0xe7, 0x27,
	0x97, 0x09, 0xc3, 0xba, 0x89, 0x8f, 0x11, 0x03, 0x57, 0xb8, 0x91, 0xb5, 0x8c, 0x04, 0x2e, 0xd1,
	0x7b, 0xb5, 0xf2, 0x64, 0x69, 0xba, 0x43, 0x3e, 0x31, 0x93, 0xa5, 0xc7, 0xda, 0x8d, 0xee, 0x71,
	0x96, 0xb1, 0x2c, 0x1f, 0x41, 0x3e, 0x23, 0x98, 0xf6, 0xb4, 0x4d, 0x83, 0xb9, 0x7c, 0x54, 0x35,
	0x31, 0x46, 0x99, 0x9b, 0x00, 0xdc, 0xd9, 0x32, 0x6f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00
};

/*
	On "v2.5_others" response.
	
	This is what the server sends as file as a signature to proves himself.
	
	File name: 8cb38e6d076d275d_01188001
*/
std::vector<unsigned char> example_A_other_packet2 =
{
	// Query type
	0x01, 0x18, 0x80, 0x06,
	
	// Same data as the ps2 sends in packet1,.. can be basically repeated...
	0x01, 0x0e, 0x5c, 0x55, 0x17, 0x38, 0x16, 0x12, 0x09, 0x07, 0xe0, 0x00, 0x00, 0x33, 0xa8, 0x00,
	0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00,
	
	// * Unknown
	0x8c, 0xb3, 0x8e, 0x6d, 0x07, 0x6d, 0x27, 0x5d, 0xdf, 0x00, 0x00, 0x00, 0x82,
	
	// Can be disabled...
	//0x02, 0x01, 0xa6, 0x70, 0x7b, 0x55, 0xb4, 0x28, 0x97, 0xa3, 0x7e, 0x3a, 0xfa, 0xd3, 0xe4, 0x54,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0xac, 0xb7, 0xeb, 0x68, 0xc7, 0xf5, 0xb4, 0x19, 0xbe, 0x1c, 0x9c, 0x4d, 0x62, 0xcc, 0xa9, 0xbf,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0xa1, 0x66, 0xed, 0xf9, 0x4e, 0x6a, 0x44, 0x99, 0xc0, 0xfb, 0x9c, 0x14, 0xd7, 0x67, 0x45, 0x85,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x0d, 0x4f, 0xe9, 0x2d, 0x35, 0x10, 0xe5, 0xf9, 0xec, 0x2c, 0x82, 0x8e, 0xf1, 0xae, 0x37, 0x55,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0xc3, 0xe1, 0xe4, 0x16, 0xb4, 0x9c, 0xee, 0x7c, 0x5a, 0x53, 0x24, 0xe4, 0x53, 0xdb, 0x48, 0x88,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0xc7, 0xdc, 0x77, 0xd8, 0x90, 0xad, 0x82, 0x31, 0xca, 0x28, 0x64, 0x10, 0xe7, 0x3e, 0x4c, 0xe0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x85, 0x8c, 0xa7, 0xbb, 0xc2, 0xb5, 0xd7, 0xc7, 0x6c, 0x48, 0x35, 0x15, 0xb2, 0x3b, 0x32, 0x34,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x77, 0x0d, 0x2c, 0xf0, 0x4f, 0xc9, 0x2b, 0xba, 0x49, 0x59, 0x02, 0xac, 0xef, 0x72, 0x27, 0x02,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0xfc, 0xaf
	0xff, 0xff,
};

// 
// Game: Medal of Honor - Rising Sun (us)
// 
/*
	On "v2.5_i-connect" request.
	
	This is what the ps2 sends as a file. This file content is used as a kind of ?challenge?.
*/
std::vector<unsigned char> example_B_packet1 =
{
	// Query type
	0x01, 0x18, 0x00, 0x00,
	
	// ? Unknown ?
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x0c, 0x00, 0x02, 0x00, 0x05,
	
	// Game ID: This value can be found in the game files
	0x00, 0x44, 0xd7, 0x11, 0xbb, 0x7b, 0xfb, 0x3a,
	
	// Random data
	0xdb, 0x2b, 0x1d, 0x3d, 0x4a, 0xdc, 0xc9, 0x60, 0x51, 0x81, 0x7a, 0x00, 0xe9, 0x86, 0x5f, 0x1c,
	0x33, 0xe4, 0xef, 0x8a, 0xf9, 0x52, 0xbd, 0xe4, 0x12, 0xfc, 0xfa, 0xe7, 0xf2, 0xe5, 0x1b, 0xc1,
	0x45, 0x92, 0xc6, 0x83, 0xd8, 0x47, 0x46, 0x6e, 0x1a, 0x26, 0x24, 0x50, 0xc6, 0xe9, 0xcb, 0x8b,
	0x73, 0xd5, 0x9a, 0x4c, 0x8b, 0x65, 0x2d, 0x20, 0x5b, 0x96, 0x54, 0xa2, 0x60, 0x42, 0xe9, 0xc9,
	0x7b, 0x74, 0xed, 0x8d, 0x2e, 0x19, 0xe6, 0x99, 0x8c, 0x00, 0x69, 0xfa, 0x56, 0x2b, 0x73, 0x74,
	0x88, 0x99, 0xee, 0xdd, 0x97, 0x87, 0xe7, 0x0a, 0x49, 0x73, 0xd1, 0x22, 0xbc, 0x87, 0x9e, 0xb4,
	0xbe, 0xe6, 0xc5, 0x45, 0x73, 0x38, 0x13, 0x0d, 0xc2, 0xe2, 0x90, 0xfc, 0x1a, 0xec, 0xa4, 0x04,
	0x55, 0x5f, 0x17, 0x1e, 0x7e, 0x65, 0x98, 0xb4, 0x4f, 0xcb, 0xbd, 0xc0, 0x74, 0x5c, 0x4a, 0x70,
	0x1d, 0x02, 0xda, 0x59, 0xa0, 0x4d, 0xa8, 0x3a, 0x32, 0xbc, 0x4a, 0xef, 0x5a, 0x97, 0x59, 0xb4,
	0xbb, 0x10, 0xef, 0x67, 0x63, 0x70, 0x27, 0x41, 0xc1, 0x13, 0xba, 0xf2, 0x46, 0x4f, 0xb9, 0x87,
	0x92, 0x6c, 0x07, 0xce, 0x1d, 0xb2, 0x75, 0xaa, 0x36, 0x7e, 0xe5, 0x36, 0x7f, 0x8d, 0x57, 0x76,
	0xdb, 0xbd, 0x6b, 0xe8, 0xde, 0x8f, 0x1d, 0x7c, 0x4c, 0x55, 0x15, 0xbb, 0x5e, 0x95, 0x0d, 0xc8,
	0x01, 0x29, 0xad, 0x7c, 0xb2, 0x93, 0x9b, 0x60, 0x37, 0x70, 0x24, 0x93, 0x95, 0xc6, 0x47, 0xb8,
	0x13, 0x55, 0x5d, 0xb0, 0x85, 0xb0, 0x7b, 0xe4, 0x86, 0x84, 0x2f, 0x86, 0x85, 0x9d, 0x34, 0xdd,
	0xca, 0xca, 0x57, 0x38, 0x7a, 0xf9, 0x0b, 0x5a, 0xbc, 0x4a, 0x6d, 0x23, 0xcf, 0x1b, 0x7a, 0x07,
	0xd1, 0x92, 0x45, 0x32, 0xe8, 0x0a, 0xed, 0x7a, 0x4d, 0xa2, 0xff, 0x2c, 0xd9, 0x8c, 0x34, 0xb0, 
};

/*
	On "v2.5_i-connect" response.
	
	This is what the server sends as file as a signature to proves himself.
	
	File name: 0044d711bb7bfb3a_01180000
*/
std::vector<unsigned char> example_B_packet2 =
{
	// Query type
	0x01, 0x18, 0x00, 0x05,
	
	// * Can be disabled for first request but needs it for second other request
	0x01, 0x0f, 0x17, 0xb0, 0x22, 0x2e, 0x0a, 0x19, 0x09, 0x07, 0xe0, 0x00, 0x00, 0x16, 0xa4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x35, 0x78, 0x71, 0x26, 0x83, 0xbd, 0x27, 0x99,
	
	// Looks like a static value that never change
	0x00, 0x00, 0x01, 0x20,
	
	// Can be disabled...
	//0x0c, 0xa5, 0x1d, 0x16, 0xb7, 0x1d, 0xad, 0x2d, 0xc0, 0xb1, 0xa0, 0x74, 0x25, 0x03, 0x7e, 0x89,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x41, 0x5f, 0xd7, 0xfd, 0x21, 0x52, 0x72, 0xea, 0x76, 0x5d, 0xb9, 0xad, 0xfb, 0x96, 0x9f, 0x47,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	
	// *
	0x74, 0x2c, 0x0a, 0xcf, 0x77, 0x42, 0x46, 0x43, 0x32, 0x4d, 0xf3, 0x7a, 0x89, 0x19, 0x77, 0x7a,
	0x56, 0x60, 0xe8, 0x3c, 0x22, 0x64, 0x56, 0x36, 0x9d, 0x0d, 0x2d, 0x9a, 0xd9, 0xe9, 0x3b, 0xb2,
	0xce, 0x32, 0x06, 0x87, 0x7d, 0x81, 0x09, 0x63, 0x1a, 0xd6, 0xe8, 0xf4, 0xbc, 0x4b, 0x82, 0x52,
	0xf1, 0xc2, 0x66, 0xb8, 0x09, 0x91, 0x6a, 0x21, 0x43, 0xf7, 0x66, 0xe4, 0xb8, 0xc5, 0x98, 0x49,
	0x4b, 0x70, 0xee, 0x5c, 0x21, 0x6e, 0xd4, 0x8a, 0x75, 0x51, 0x58, 0x3f, 0xe8, 0xdf, 0x8f, 0x02,
	0xea, 0xe2, 0x19, 0xee, 0xc7, 0x65, 0x6a, 0x23, 0x15, 0xc5, 0xb8, 0x0c, 0x70, 0xa5, 0x14, 0x1c,
	0x86, 0xb1, 0xbc, 0x60, 0x13, 0x3f, 0xaa, 0x0f, 0x74, 0xe8, 0xd8, 0x0f, 0xad, 0xa8, 0xe5, 0xfe,
	0x25, 0xdb, 0xfa, 0x84, 0x10, 0x6a, 0xa1, 0x49, 0x91, 0x16, 0x7d, 0x3b, 0xd7, 0x42, 0xd4, 0x24,
	0xe0, 0x80, 0x76, 0x4e, 0xf5, 0xc1, 0x0c, 0x97, 0x36, 0xd6, 0xe3, 0xe9, 0x4c, 0x23, 0x02, 0x2f,
	0x4f, 0x09, 0xe0, 0xb7, 0xc6, 0x14, 0xc2, 0x40, 0x9a, 0x79, 0xa3, 0x5c, 0xd7, 0xc4, 0xb7, 0xb7,
	
	// Can be disabled...
	//0xCA, 0x74, 0x79, 0x06, 0x06, 0xA8, 0xDA, 0x77, 0x9E, 0x37, 0x57, 0xCA, 0x62, 0xD2, 0xEE, 0x21,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x6A, 0x1A, 0x1A, 0x05, 0x50, 0xF3, 0x00, 0xD0, 0x07, 0x85, 0xBD, 0x19, 0xAD, 0x01, 0x9D, 0x77,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x75, 0x16, 0x7E, 0x7C, 0xBF, 0x58, 0xF4, 0x5E, 0x90, 0x4B, 0x28, 0xF2, 0x1E, 0x17, 0x14, 0x88,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x32, 0x2E, 0x8D, 0x82, 0x21, 0x8E, 0x53, 0x29, 0x13, 0x10, 0x42, 0xC0, 0x12, 0xDF, 0x37, 0x88,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0xF6, 0xB5, 0x04, 0xB6, 0x0E, 0xF9, 0x14, 0x9E, 0x44, 0x3D, 0x91, 0x63, 0x55, 0xA6, 0xEB, 0x87,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0xD4, 0x79, 0x0A, 0xF6, 0x07, 0x5D, 0x1F, 0x1B, 0x6E, 0x61, 0xDC, 0x80, 0x41, 0x14, 0x09, 0x38,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

/*
	On "v2.5_i-connect" request.
	
	This is what the ps2 sends as a file. This file content is used as a kind of ?challenge?.
*/
std::vector<unsigned char> example_B_packet1_2 =
{
	// Query type
	0x01, 0x08, 0x00, 0x00,
	
	// ? Unknown ?
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x0c, 0x00, 0x02, 0x00, 0x05,
	
	// Game ID: This value can be found in the game files
	0x00, 0x44, 0xd7, 0x11, 0xbb, 0x7b, 0xfb, 0x3a,
	
	// Random data
	0xfe, 0x2a, 0x25, 0xe0, 0x2f, 0x33, 0xa1, 0xa4, 0x2e, 0xe3, 0x4c, 0xfe, 0x6c, 0xc6, 0x0b, 0xd4,
	0x9b, 0xe8, 0x5f, 0x3e, 0x40, 0x98, 0xa7, 0x20, 0x99, 0xc7, 0x8a, 0xdd, 0x53, 0x62, 0x3e, 0xb5,
	0x0e, 0x04, 0x11, 0xb1, 0x23, 0x79, 0xb0, 0x54, 0x30, 0xd2, 0xcc, 0x3f, 0xa6, 0x55, 0x69, 0x1f,
	0x5a, 0x8d, 0xec, 0xba, 0x11, 0x28, 0x7d, 0xdd, 0x22, 0x71, 0x36, 0x3a, 0x9e, 0xd2, 0x58, 0xab,
	0xa4, 0x07, 0xd0, 0x33, 0x73, 0xe2, 0x8f, 0x31, 0xbf, 0x42, 0x29, 0xad, 0xe0, 0xd1, 0x33, 0x73,
	0xc7, 0x35, 0x7f, 0x50, 0x99, 0xbb, 0xa0, 0x23, 0x61, 0xb8, 0x18, 0xce, 0xd7, 0xa6, 0x01, 0x4c,
	0x56, 0x35, 0xfc, 0xcf, 0xba, 0x9c, 0x5e, 0xac, 0x35, 0xc8, 0x19, 0x1c, 0x62, 0x4c, 0x3b, 0x20,
	0xc9, 0x59, 0xc4, 0x8f, 0x16, 0x60, 0x27, 0x7c, 0xf1, 0xec, 0xae, 0x7c, 0xe8, 0x76, 0x8e, 0xf2,
	0xab, 0x03, 0xdd, 0xf6, 0xaf, 0x8e, 0x5e, 0xc8, 0x4a, 0x8e, 0x5d, 0x0b, 0x92, 0x38, 0x69, 0x58,
	0x57, 0x48, 0x57, 0xb0, 0x64, 0xd6, 0xb7, 0xfa, 0x09, 0x51, 0x07, 0xc8, 0xbf, 0x9f, 0x0d, 0x05,
	0x98, 0x9f, 0xd6, 0x14, 0x9b, 0xc0, 0x71, 0x4d, 0xdd, 0xf3, 0x27, 0x30, 0x9b, 0x3c, 0x5a, 0x3e,
	0x72, 0xbf, 0xf4, 0x46, 0x46, 0x87, 0x3c, 0xab, 0x39, 0x08, 0x42, 0xe0, 0x4d, 0xce, 0xc9, 0x17,
	0x31, 0xe6, 0x30, 0x73, 0xed, 0x74, 0x32, 0xa5, 0x51, 0xb8, 0x10, 0xbf, 0x9d, 0xf9, 0x0a, 0xff,
	0xaa, 0x83, 0xcd, 0x26, 0xaf, 0xda, 0x13, 0x8e, 0x6a, 0xd2, 0xbf, 0x5e, 0xdc, 0x94, 0xdd, 0x6a,
	0xc9, 0x13, 0xea, 0x0c, 0x4a, 0x59, 0xad, 0xe1, 0xc1, 0x42, 0x27, 0xd7, 0x80, 0xd8, 0x04, 0x48,
	0x86, 0xec, 0xeb, 0x3d, 0xd0, 0xeb, 0x9a, 0xf3, 0xb0, 0xc4, 0x31, 0x4e, 0x9e, 0x04, 0xe6, 0x8f, 
};

/*
	On "v2.5_i-connect" response.
	
	This is what the server sends as file as a signature to proves himself.
	
	File name: 0044d711bb7bfb3a_01080000
	Game: Medal of Honor - Rising Sun (us)
*/
std::vector<unsigned char> example_B_packet2_2 =
{
	// Query type
	0x01, 0x08, 0x00, 0x05,
	
	// * Can be disabled for first request but needs it for second other request
	0x01, 0x00, 0x89, 0xa7, 0x31, 0x2e, 0x0a, 0x19, 0x09, 0x07, 0xe0, 0x00, 0x00, 0x76, 0xa1, 0x00,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0xb5, 0x56, 0xb9, 0xaf, 0x95, 0x62, 0xcc, 0x6b, 0xa2,
	
	// Looks like a static value that never change
	0x00, 0x00, 0x01, 0x20,
	
	// Can be disabled...
	//0x73, 0xf4, 0xbd, 0x4b, 0x95, 0xb8, 0x02, 0xe7, 0xcc, 0x78, 0xcf, 0xce, 0xee, 0x73, 0xea, 0x63,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0xda, 0x6e, 0x4a, 0xa5, 0x42, 0x89, 0x25, 0xdf, 0x80, 0xf7, 0xad, 0xa4, 0xa6, 0xe7, 0x82, 0xef,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	
	// *
	0x3d, 0x80, 0x2e, 0x56, 0x91, 0xa8, 0x99, 0xb1, 0xeb, 0xf1, 0xbb, 0x14, 0x3f, 0xeb, 0xbe, 0x3d,
	0x2b, 0xb3, 0xbe, 0x8e, 0xec, 0x35, 0x8d, 0xb6, 0x5a, 0x06, 0x3e, 0x00, 0x4f, 0xf7, 0xbf, 0xa4,
	0x30, 0x86, 0x54, 0xf0, 0x4d, 0x96, 0x57, 0x81, 0x31, 0x87, 0x56, 0x35, 0xdf, 0xde, 0xe6, 0x75,
	0xb3, 0xfe, 0xb7, 0xb0, 0x44, 0xea, 0x7e, 0x2d, 0xa1, 0xd4, 0x14, 0xef, 0xb6, 0xd4, 0xbd, 0x71,
	0x4a, 0xfb, 0xd6, 0x7a, 0xca, 0xab, 0x71, 0x71, 0x01, 0x2c, 0xc5, 0x07, 0x41, 0xaa, 0x62, 0x6f,
	0xec, 0xc2, 0xca, 0xa5, 0x11, 0xc4, 0xca, 0x52, 0x67, 0x63, 0xa7, 0xf1, 0x6b, 0xa9, 0xb5, 0x84,
	0x7e, 0xf5, 0x0f, 0xf0, 0xae, 0x33, 0xcb, 0x8f, 0xbe, 0xb1, 0x3b, 0x00, 0x6f, 0xe6, 0xc1, 0xf6,
	0x93, 0xa1, 0x6a, 0x23, 0xad, 0x40, 0x75, 0xcf, 0x19, 0x66, 0xd4, 0xb4, 0xf8, 0xd9, 0x8d, 0x12,
	0xe0, 0x80, 0x76, 0x4e, 0xf5, 0xc1, 0x0c, 0x97, 0x36, 0xd6, 0xe3, 0xe9, 0x4c, 0x23, 0x02, 0x2f,
	0x4f, 0x09, 0xe0, 0xb7, 0xc6, 0x14, 0xc2, 0x40, 0x9a, 0x79, 0xa3, 0x5c, 0xd7, 0xc4, 0xb7, 0xb7,
	
	// Can be disabled...
	//0x9d, 0x09, 0x47, 0x8b, 0xca, 0x1b, 0xb0, 0x93, 0x51, 0x61, 0x6f, 0x62, 0x90, 0x05, 0xde, 0xbe,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x92, 0x26, 0xff, 0xd2, 0xe5, 0x90, 0x95, 0x61, 0xff, 0x44, 0x90, 0x12, 0x8a, 0xff, 0x26, 0x27,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x08, 0x6d, 0xb3, 0xd2, 0x89, 0x63, 0x66, 0xdb, 0xc5, 0xd5, 0x3d, 0x55, 0xdb, 0x1b, 0x14, 0x6e,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x42, 0x13, 0x41, 0x27, 0xa4, 0xd6, 0x89, 0xa4, 0x1b, 0x1a, 0xb6, 0xa6, 0x19, 0xdd, 0xce, 0x21,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x4b, 0x81, 0xf4, 0xd5, 0xe4, 0x5b, 0xb0, 0xa9, 0x30, 0xed, 0xfe, 0x0c, 0x09, 0x13, 0x7a, 0x4c,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x27, 0xbb, 0x73, 0xcb, 0x92, 0xfd, 0x6f, 0xae, 0x17, 0x26, 0x54, 0x31, 0x03, 0x23, 0x53, 0x4f
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

/*
	On "v2.5_others" request.
	
	This is what the ps2 sends as a file. This file content is used as a kind of ?challenge?.
*/
std::vector<unsigned char> example_B_other_packet1 =
{
	// Query type
	0x01, 0x18, 0x80, 0x01,
	
	// Unknown
	0x01, 0x0f, 0x17, 0xb0, 0x22, 0x2e, 0x0a, 0x19, 0x09, 0x07, 0xe0, 0x00, 0x00, 0x16, 0xa4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	
	// Response ID
	0x7c, 0x35, 0x78, 0x71, 0x26, 0x83, 0xbd, 0x27,
	
	// Unknown
	0x99, 0x00, 0x00, 0x00, 0x90, 0xe2, 0x23, 0x5b, 0x09, 0xdc, 0xa3, 0xaf, 0x48, 0xe2, 0x23, 0x5b,
	0x09, 0xdc, 0xa3, 0xaf, 0x48, 0xd3, 0xa9, 0x8d, 0x1e, 0xdb, 0xa0, 0x95, 0xf1, 0xbe, 0x3b, 0xfe,
	0xeb, 0xe8, 0x1b, 0xa3, 0xa7, 0xf1, 0x74, 0x78, 0x98, 0x82, 0x1f, 0x11, 0x8e, 0x90, 0xb2, 0x0e,
	0xb5, 0xe2, 0xc0, 0x3c, 0xb6, 0x69, 0xc9, 0xd5, 0x45, 0x6a, 0x6a, 0x36, 0x28, 0xa5, 0x34, 0x14,
	0x8e, 0x50, 0xb7, 0x36, 0x42, 0x2b, 0xae, 0xda, 0xad, 0xcd, 0xec, 0x3b, 0x5e, 0x9e, 0x4a, 0x14,
	0x81, 0x0a, 0x50, 0x37, 0x74, 0x19, 0x0d, 0xb9, 0x83, 0x77, 0xef, 0xac, 0x1d, 0x24, 0xc0, 0xab,
	0x75, 0x77, 0xe1, 0xb7, 0xa3, 0x8f, 0x92, 0x50, 0x5d, 0x7e, 0x8c, 0xbc, 0x1d, 0xd6, 0xd0, 0x9e,
	0xe1, 0x20, 0xd6, 0x55, 0x3a, 0xe3, 0x0e, 0xbe, 0x5a, 0xfe, 0x6a, 0x78, 0x23, 0x2b, 0x23, 0x98,
	0xa2, 0x05, 0x50, 0x46, 0x95, 0xe3, 0x97, 0xf2, 0x61, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 
};

/*
	On "v2.5_others" response.
	
	This is what the server sends as file as a signature to proves himself.
	
	File name: 7c3578712683bd27_01188001
	Game: Medal of Honor - Rising Sun (us)
*/
std::vector<unsigned char> example_B_other_packet2 =
{
	// Query type
	0x01, 0x18, 0x80, 0x06,
	
	// Same data as the ps2 sends in packet1,.. can be basically repeated...
	0x01, 0x0f, 0x17, 0xb0, 0x22, 0x2e, 0x0a, 0x19, 0x09, 0x07, 0xe0, 0x00, 0x00, 0x16, 0xa4, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	
	// * Unknown
	0x7c, 0x35, 0x78, 0x71, 0x26, 0x83, 0xbd, 0x27, 0x99, 0x00, 0x00, 0x00, 0x82,
	
	// Can be disabled...
	//0x02, 0x01, 0x6c, 0x2e, 0xca, 0xc8, 0xef, 0x80, 0xa0, 0x7d, 0x26, 0x77, 0xb4, 0x9d, 0x4a, 0xf3,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x8e, 0xee, 0x31, 0xc0, 0x81, 0x41, 0xfc, 0x63, 0xda, 0x89, 0xde, 0xa6, 0x41, 0xfd, 0xc9, 0x01,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x25, 0x14, 0x5d, 0xbb, 0xcb, 0xe0, 0xdd, 0x46, 0x01, 0x42, 0xe5, 0x9c, 0x62, 0x5a, 0x66, 0x50,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0xd3, 0x6c, 0x49, 0x5b, 0xb8, 0x11, 0x55, 0xcb, 0xf5, 0x98, 0xa0, 0x2b, 0x03, 0x67, 0xb0, 0x6d,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x51, 0xdc, 0x8b, 0xb9, 0x94, 0xe5, 0x90, 0x49, 0x2c, 0x9a, 0x5d, 0xf2, 0xc1, 0x26, 0x76, 0x50,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x46, 0x73, 0xca, 0xab, 0x42, 0xec, 0xf2, 0x17, 0xda, 0xb9, 0x41, 0x8b, 0x75, 0xfa, 0x5d, 0x92,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x93, 0xa4, 0xc9, 0x98, 0x5c, 0x69, 0x87, 0xd8, 0xa4, 0x5e, 0x41, 0xf2, 0x37, 0xe4, 0x97, 0xe4,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x61, 0x09, 0x3b, 0xb6, 0xc7, 0xea, 0x78, 0x64, 0x9b, 0x86, 0xde, 0xbd, 0x6c, 0xac, 0xaa, 0xf9,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0xb0, 0xc9
	0xff, 0xff,
};

/*
	On "v2.5_others" request.
	
	This is what the ps2 sends as a file. This file content is used as a kind of ?challenge?.
*/
std::vector<unsigned char> example_B_other_packet1_2 =
{
	// Query type
	0x01, 0x08, 0x00, 0x01,
	
	// Unknown
	0x01, 0x00, 0x89, 0xa7, 0x31, 0x2e, 0x0a, 0x19, 0x09, 0x07, 0xe0, 0x00, 0x00, 0x76, 0xa1, 0x00,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
	
	// Response ID
	0xb5, 0x56, 0xb9, 0xaf, 0x95, 0x62, 0xcc, 0x6b,
	
	// Unknown
	0xa2, 0x00, 0x00, 0x00, 0x90, 0xe2, 0x23, 0x5b, 0x09, 0xdc, 0xa3, 0xaf, 0x48, 0xe2, 0x23, 0x5b,
	0x09, 0xdc, 0xa3, 0xaf, 0x48, 0x39, 0x07, 0x1f, 0xe7, 0x83, 0x7e, 0x68, 0xce, 0x3b, 0x5c, 0x42,
	0x22, 0x5e, 0xfa, 0xb8, 0xcd, 0x31, 0xd0, 0x42, 0x3e, 0x73, 0xd9, 0xa8, 0x0c, 0xa4, 0x0f, 0x90,
	0x59, 0x02, 0xb0, 0x7a, 0x3b, 0xb7, 0x9a, 0x22, 0x3b, 0x19, 0x8b, 0x09, 0x54, 0xe7, 0x4c, 0x76,
	0x45, 0x46, 0x2e, 0x13, 0x78, 0xff, 0x55, 0xb7, 0x72, 0x2f, 0x60, 0x7f, 0xd3, 0x70, 0x0f, 0x2c,
	0x72, 0xc0, 0xa7, 0xad, 0x77, 0x42, 0xd0, 0xb2, 0x5b, 0x5b, 0xbc, 0xb0, 0x43, 0x09, 0x26, 0x89,
	0x50, 0x55, 0x9c, 0xc9, 0x54, 0xf1, 0x80, 0xc7, 0x20, 0xe1, 0x46, 0xf3, 0x52, 0x56, 0x20, 0xc4,
	0x16, 0xc8, 0x72, 0x8d, 0x0b, 0x43, 0x40, 0x67, 0x9f, 0xfd, 0x17, 0xe2, 0x06, 0x3e, 0x6c, 0x56,
	0x93, 0x08, 0x1f, 0xe8, 0xf9, 0xa0, 0xb0, 0x1a, 0x82, 0xf6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 
};

/*
	On "v2.5_others" response.
	
	This is what the server sends as file as a signature to proves himself.
	
	File name: b556b9af9562cc6b_01080001
	Game: Medal of Honor - Rising Sun (us)
*/
std::vector<unsigned char> example_B_other_packet2_2 =
{
	// Query type
	0x01, 0x08, 0x00, 0x06,
	
	// Same data as the ps2 sends in packet1,.. can be basically repeated...
	0x01, 0x00, 0x89, 0xa7, 0x31, 0x2e, 0x0a, 0x19, 0x09, 0x07, 0xe0, 0x00, 0x00, 0x76, 0xa1, 0x00,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
	
	// * Unknown data
	0xb5, 0x56, 0xb9, 0xaf, 0x95, 0x62, 0xcc, 0x6b, 0xa2, 0x00, 0x00, 0x00, 0x82,
	
	// Can be disabled...
	//0x02, 0x01, 0x68, 0x74, 0x6c, 0x9a, 0xb7, 0x7c, 0xf9, 0x93, 0xa4, 0xd6, 0xe8, 0xb0, 0xb1, 0xc7,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x58, 0x3f, 0x56, 0x6a, 0x51, 0x2a, 0x1e, 0x6c, 0x34, 0x13, 0xf2, 0x8b, 0x09, 0x90, 0xde, 0x42,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x2f, 0xed, 0xf6, 0x12, 0x1c, 0x85, 0x32, 0xf3, 0x49, 0x50, 0xee, 0x0e, 0x29, 0x5e, 0xec, 0xf2,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0xcd, 0xe9, 0xee, 0x34, 0x28, 0xf4, 0x76, 0x2b, 0x87, 0xb3, 0x21, 0x27, 0xbb, 0xc1, 0xe3, 0xd0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x9c, 0xda, 0xd8, 0xed, 0x52, 0xa4, 0xa4, 0xef, 0xdc, 0x60, 0x40, 0xac, 0x81, 0xae, 0x0c, 0x55,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x91, 0x47, 0x4c, 0x43, 0x5f, 0x06, 0x59, 0x98, 0xc4, 0x21, 0x9d, 0x38, 0x22, 0x47, 0xbf, 0xae,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x59, 0x95, 0xec, 0x85, 0x80, 0x12, 0x6b, 0x2c, 0x36, 0x29, 0x4b, 0x26, 0xff, 0xf7, 0x20, 0x2e,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x80, 0x08, 0x33, 0xec, 0xa1, 0x57, 0xd7, 0x0c, 0xe0, 0xff, 0xb3, 0x20, 0x66, 0x3c, 0x5a, 0xc9,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x70, 0xff
	0xff, 0xff,
};

/*
	On "v2.5_others" request.
	
	This is what the ps2 sends as a file. This file content is used as a kind of ?challenge?.
*/
std::vector<unsigned char> example_B_other_packet1_3 =
{
	// Query type
	0x01, 0x08, 0x80, 0x08,
	
	// Unknown
	0x01, 0x00, 0x89, 0xa7, 0x31, 0x2e, 0x0a, 0x19, 0x09, 0x07, 0xe0, 0x00, 0x00, 0x76, 0xa1, 0x00,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0xb5, 0x56, 0xb9, 0xaf, 0x95, 0x62, 0xcc, 0x6b, 0xa2,
	0x00, 0x00, 0x00,
	
	0x04, 0x3c, 0x33, 0x60, 0x96, 
};

/*
	On "v2.5_others" response.
	
	This is what the server sends as file as a signature to proves himself.
	
	File name: b556b9af9562cc6b_01088008
	Game: Medal of Honor - Rising Sun (us)
*/
std::vector<unsigned char> example_B_other_packet2_3 =
{
	// Query type
	0x01, 0x08, 0x80, 0x0d,
	
	// Same data as the ps2 sends in packet1,.. can be basically repeated...
	0x01, 0x00, 0x89, 0xa7, 0x31, 0x2e, 0x0a, 0x19, 0x09, 0x07, 0xe0, 0x00, 0x00, 0x76, 0xa1, 0x00,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0xb5, 0x56, 0xb9, 0xaf, 0x95, 0x62, 0xcc, 0x6b, 0xa2,
	0x00, 0x00, 0x00,
	
	// * Unknown data
	0x25, 0x01, 0x00, 0x00, 0x00, 0x20,
	
	// Can be disabled...
	//0xb9, 0xae, 0x75, 0xb4, 0xa3, 0x9d, 0xbd, 0x70, 0xac, 0xab, 0x07, 0x67, 0x60, 0xae, 0xc0, 0x9d,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	//0x72, 0x25, 0x7f, 0x3e, 0xc0, 0x59, 0x51, 0x7b, 0x9f, 0xa0, 0x3a, 0x8a, 0xeb, 0xf6, 0x18, 0x7a
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};



typedef void (DNASBypass::Client::*RequestActionFunc)(const std::vector<unsigned char>&, const atomizes::HTTPMessage&,
		const UrlRequest::UrlVariables&);

static std::map<std::string, RequestActionFunc> mRequestActions = 
{
	// US
	{ "/us-gw/v2.5_i-connect",    &DNASBypass::Client::requestConnect },
	{ "/us-gw/v2.5_others",       &DNASBypass::Client::requestOther   },
	
	// EU
	{ "/eu-gw/v2.5_i-connect",    &DNASBypass::Client::requestConnect },
	{ "/eu-gw/v2.5_others",       &DNASBypass::Client::requestOther   },
};

DNASBypass::Client::Client(int socket, struct sockaddr_in address, SSL* ssl)
{
	this->_socket = socket;
	this->_address = address;
	this->_ssl = ssl;
}

DNASBypass::Client::~Client()
{
	this->Disconnect();
}

void DNASBypass::Client::Listen()
{
	// Create a new SSL connection object for the client
	SSL_set_fd(this->_ssl, this->_socket);

	// Perform the SSL handshake
	if (SSL_accept(this->_ssl) <= 0)
	{
		Logger::warning("SSL handshake failed", Server::Type::DNASBypass);
	}
	else
	{
		Logger::info("SSL handshake accepted", Server::Type::DNASBypass);
		
		while(true)
		{
			std::vector<unsigned char> buffer(4096, 0);
			HTTPMessageParser http_parser;
			HTTPMessage http_request;
			
			int v = SSL_read(this->_ssl, &(buffer[0]), 4096);
			
			// If error or no data is recieved we end the connection
			if(v <= 0)
			{
				break;
			}
			
			// Resize buffer
			buffer.resize(v);
			
			std::vector<char> buffer2(buffer.begin(), buffer.end());
			
			// Parse buffer to http header
			http_parser.Parse(&http_request, &(buffer2[0]));
			
			// Debug
			//Logger::debug(http_request.ToString());
			
			this->onRequest(buffer, http_request);
		}
	}
	
	this->Disconnect();
}

void DNASBypass::Client::Disconnect()
{
	SSL_shutdown(this->_ssl);
	SSL_free(this->_ssl);
	
	this->Close();
	g_dnasbypass_server->onClientDisconnect(*this);
}

void DNASBypass::Client::Send(const std::string& msg) const
{
	std::lock_guard<std::mutex> guard(this->_mutex); // socket lock (read/write)
	
	SSL_write(this->_ssl, msg.c_str(), msg.size());
}

void DNASBypass::Client::Send(const std::vector<unsigned char>& msg) const
{
	std::lock_guard<std::mutex> guard(this->_mutex); // socket lock (read/write)
	
	SSL_write(this->_ssl, &(msg[0]), msg.size());
}

/*
	Events
*/
void DNASBypass::Client::onRequest(const std::vector<unsigned char>& request, const atomizes::HTTPMessage &http_request)
{
	if(http_request.GetMethod() == MessageMethod::POST)
	{
		std::string url_base;
		UrlRequest::UrlVariables url_variables;
		
		this->_LogTransaction("-->", http_request.GetPath());
		
		// Split url into url base and variables
		UrlRequest::GetUrlElements(http_request.GetPath(), url_base, url_variables);
		
		auto it = mRequestActions.find(url_base);
		if (it != mRequestActions.end())
		{
			// Get Function address
			RequestActionFunc func = it->second;
		
			// Execute action function with class object.
			(this->*(func))(request, http_request, url_variables);
		}
		else
		{
			Logger::warning("action \"" + url_base + "\" not implemented!", Server::Type::DNASBypass);
		}
	}
	else
	{
		Logger::warning("And none POST request recieved!", Server::Type::DNASBypass);
	}
}

void DNASBypass::Client::requestConnect(const std::vector<unsigned char>& request, const atomizes::HTTPMessage& http_request,
		const UrlRequest::UrlVariables& url_variables)
{
	std::string   game_id;
	std::string   query_type;
	std::string   file_name;
	std::vector<unsigned char> packet1;
	std::vector<unsigned char> packet2 = example_B_packet2;
	std::vector<unsigned char> packet4;
	std::vector<unsigned char> v_response;
	std::string response;
	
	// Get content length, because this http header exist twice we need to take the first
	size_t content_length = this->_GetContentLength(http_request);
	
	if(request.size() < content_length)
	{
		return; // WTF?!
	}
	
	// Get requested file data
	packet1.assign(request.end() - content_length, request.end());
	
	// Get information
	GetFileName(packet1, game_id, query_type, file_name);
	
	if(file_name      == "0044d711bb7bfb3a_01180000")
		packet2 = example_B_packet2;
	else if(file_name == "0044d711bb7bfb3a_01080000")
		packet2 = example_B_packet2_2;
	// Battlefield
	else if(file_name == "ca0810767e461a49_01180000")
		packet2 = example_A_packet2;
	
	// Sign data
	Sign(packet1, packet2, packet4);
	
	// Create HTTP headers
	response += "HTTP/1.0 200 OK\r\n";
	response += "Content-Type: image/gif\r\n";
	response += "Content-Length: " + std::to_string(packet4.size()) + "\r\n\r\n";
	
	// Combine HTTP header with file content
	v_response.reserve(response.size() + packet4.size());
	std::copy(response.begin(), response.end(), std::back_inserter(v_response));
	std::copy(packet4.begin(), packet4.end(), std::back_inserter(v_response));
	
	// Send the response
	this->Send(v_response);
	
	this->_LogTransaction("<--", "HTTP/1.0 200 OK");
	
	// Debug
	//debugPacket("packet1", packet1);
	debugFileName(game_id, query_type, file_name);
	/*
	Logger::debug(http_request.ToString());
	Logger::debug("content_length = " + std::to_string(content_length));
	
	debugPacket("packet2", packet2);
	debugPacket("packet4", packet4);
	*/
}

void DNASBypass::Client::requestOther(const std::vector<unsigned char>& request, const atomizes::HTTPMessage& http_request, const UrlRequest::UrlVariables& url_variables)
{
	std::vector<unsigned char> packet1;
	std::string game_id;
	std::string query_type;
	std::string file_name;
	std::vector<unsigned char> packet2 = example_B_other_packet2;
	std::vector<unsigned char> v_response;
	std::string response;
	
	// Get content length, because this http header exist twice we need to take the first
	size_t content_length = this->_GetContentLength(http_request);
	
	if(request.size() < content_length)
	{
		return; // WTF?!
	}
	
	// Get requested file data
	packet1.assign(request.end() - content_length, request.end());
	
	// Extract information
	GetFileNameOther(packet1, game_id, query_type, file_name);
	
	// Medal of Honor
	if(file_name      == "7c3578712683bd27_01188001")
		packet2 = example_B_other_packet2;
	else if(file_name == "b556b9af9562cc6b_01080001")
		packet2 = example_B_other_packet2_2;
	else if(file_name == "b556b9af9562cc6b_01088008")
		packet2 = example_B_other_packet2_3;
	// Battlefield
	else if(file_name == "8cb38e6d076d275d_01188001")
		packet2 = example_A_other_packet2;
	
	// Create HTTP headers
	response += "HTTP/1.0 200 OK\r\n";
	response += "Content-Type: image/gif\r\n";
	response += "Content-Length: " + std::to_string(packet2.size()) + "\r\n\r\n";
	
	// Combine HTTP header with file content
	v_response.reserve(response.size() + packet2.size());
	std::copy(response.begin(), response.end(), std::back_inserter(v_response));
	std::copy(packet2.begin(), packet2.end(), std::back_inserter(v_response));
	
	// Send the response
	this->Send(v_response);
	
	this->_LogTransaction("<--", "HTTP/1.0 200 OK");
	
	// Debug
	debugPacket("packet1", packet1);
	/*
	
	Logger::debug(http_request.ToString());
	Logger::debug("content_length = " + std::to_string(content_length));
	
	Logger::debug("game_id = " + game_id);
	Logger::debug("query_type = " + query_type);
	Logger::debug("file_name = " + file_name);
	
	debugPacket("packet2", packet2);
	*/
}

/*
	Private functions
*/
void DNASBypass::Client::_LogTransaction(const std::string& direction, const std::string& response) const
{
	Logger::info(this->GetAddress() + " " + direction + " " + response, Server::Type::DNASBypass, true);
}

size_t DNASBypass::Client::_GetContentLength(const atomizes::HTTPMessage& http_request)
{
	size_t content_length = 0;
	
	// Get first header
	std::string str_content_length = http_request.GetHeader("Content-Length");
	
	// Convert from string to integer
	try
	{
		content_length = std::stoi(str_content_length);
	}
	catch(...) {};
	
	return content_length;
}

/*
	See "data/example/script.php"
*/
void DNASBypass::Client::Test()
{
	std::vector<unsigned char> packet1 = example_A_packet1;
	
	std::string   game_id;
	std::string   query_type;
	std::string   file_name;
	std::vector<unsigned char> chksum1(SHA_DIGEST_LENGTH, 0);
	std::vector<unsigned char> chksum2(SHA_DIGEST_LENGTH, 0);
	std::vector<unsigned char> des_key1(DES_KEY_SIZE, 0);
	std::vector<unsigned char> des_key2(DES_KEY_SIZE, 0);
	std::vector<unsigned char> des_key3(DES_KEY_SIZE, 0);
	std::vector<unsigned char> xor_seed(XOR_KEY_SIZE, 0);
	std::vector<unsigned char> des_key4  = { 0xeb, 0x71, 0x14, 0x16, 0xcb, 0x0a, 0xb0, 0x16 };
	std::vector<unsigned char> des_key5  = { 0xae, 0x19, 0x01, 0x74, 0xb5, 0xce, 0x63, 0x39 };
	std::vector<unsigned char> des_key6  = { 0x7b, 0x01, 0xb9, 0x18, 0x80, 0x14, 0x5e, 0x34 };
	std::vector<unsigned char> xor_seed2 = { 0xc5, 0x10, 0xa6, 0x40, 0x0a, 0x9b, 0x02, 0x2f };
	std::vector<unsigned char> packet2 = example_A_packet2;
	std::vector<unsigned char> packet3;
	std::vector<unsigned char> packet4;
	
	GetFileName(packet1, game_id, query_type, file_name);
	GetChecksums(packet1, chksum1, chksum2);
	GetKeysAndSeed(chksum1, chksum2, des_key1, des_key2, des_key3, xor_seed);
	
	packet3 = DNAS::encrypt3(packet2, 0xc8, 0x20, des_key1, des_key2, des_key3, xor_seed);
	packet4 = DNAS::encrypt3(packet3, 0x28, 0x120, des_key4, des_key5, des_key6, xor_seed2);
		
	// Debug
	debugPacket("packet1", packet1);
	debugFileName(game_id, query_type, file_name);
	debugCheckSum(chksum1, chksum2);
	debugDesKeys("des_key[1][2][3]", des_key1, des_key2, des_key3);
	debugXorSeed("xor_seed", xor_seed);
	debugDesKeys("des_key[4][5][6]", des_key4, des_key5, des_key6);
	debugXorSeed("xor_seed2", xor_seed2);
	debugPacket("packet2", packet2);
	debugPacket("packet3", packet3);
	debugPacket("packet4", packet4);
}

/*
	Generate checksums
*/
void DNASBypass::Client::GetChecksums(const std::vector<unsigned char>& packet1, std::vector<unsigned char>& chksum1,
	std::vector<unsigned char>& chksum2)
{
	SHA1(&(packet1[0x34]), 0x100, &(chksum1[0]));
	SHA1(&(packet1[0x48]), 0xec, &(chksum2[0]));
}

void DNASBypass::Client::GetFileName(const std::vector<unsigned char>& packet1, std::string& game_id,
		std::string& query_type, std::string& file_name)
{
	std::stringstream ss, ss2;
	
	for(int i = 0; i < 8; i++)
	{
		ss  << std::hex << std::setfill('0') << std::setw(2) << (int)(packet1[i + 0x2c]);
		
		if(i < 4)
		{
			ss2 << std::hex << std::setfill('0') << std::setw(2) << (int)(packet1[i]);
		}
	}
	game_id = ss.str();
	query_type = ss2.str();
	
	file_name = game_id + "_" + query_type;
}

void DNASBypass::Client::GetFileNameOther(const std::vector<unsigned char>& packet1, std::string& game_id,
		std::string& query_type, std::string& file_name)
{
	std::stringstream ss, ss2;
	
	for(int i = 0; i < 8; i++)
	{
		ss  << std::hex << std::setfill('0') << std::setw(2) << (int)(packet1[i + 0x1b]);
		
		if(i < 4)
		{
			ss2 << std::hex << std::setfill('0') << std::setw(2) << (int)(packet1[i]);
		}
	}
	game_id = ss.str();
	query_type = ss2.str();
	
	file_name = game_id + "_" + query_type;
}

void DNASBypass::Client::GetKeysAndSeed(const std::vector<unsigned char> chksum1, const std::vector<unsigned char> chksum2,
		std::vector<unsigned char>& des_key1, std::vector<unsigned char>& des_key2, std::vector<unsigned char>& des_key3,
		std::vector<unsigned char>& xor_seed)
{
	// Get des keys and xor seed from checksums
	for(int i = 0; i < DES_KEY_SIZE; i++)
	{
		des_key1[i] = chksum2[i];
		des_key2[i] = chksum2[8 + i];
		
		if(i < 4)
		{
			des_key3[i] = chksum2[16 + i];
			des_key3[i + 4] = chksum1[i];
		}
		
		xor_seed[i] = chksum1[i + 4];
	}
}

void DNASBypass::Client::Sign(const std::vector<unsigned char>& packet1, const std::vector<unsigned char>& packet2,
		std::vector<unsigned char>& packet4)
{
	std::vector<unsigned char> chksum1(SHA_DIGEST_LENGTH, 0);
	std::vector<unsigned char> chksum2(SHA_DIGEST_LENGTH, 0);
	std::vector<unsigned char> des_key1(DES_KEY_SIZE, 0);
	std::vector<unsigned char> des_key2(DES_KEY_SIZE, 0);
	std::vector<unsigned char> des_key3(DES_KEY_SIZE, 0);
	std::vector<unsigned char> xor_seed(XOR_KEY_SIZE, 0);
	std::vector<unsigned char> des_key4  = { 0xeb, 0x71, 0x14, 0x16, 0xcb, 0x0a, 0xb0, 0x16 };
	std::vector<unsigned char> des_key5  = { 0xae, 0x19, 0x01, 0x74, 0xb5, 0xce, 0x63, 0x39 };
	std::vector<unsigned char> des_key6  = { 0x7b, 0x01, 0xb9, 0x18, 0x80, 0x14, 0x5e, 0x34 };
	std::vector<unsigned char> xor_seed2 = { 0xc5, 0x10, 0xa6, 0x40, 0x0a, 0x9b, 0x02, 0x2f };
	std::vector<unsigned char> packet3;
	
	// Extract information
	GetChecksums(packet1, chksum1, chksum2);
	GetKeysAndSeed(chksum1, chksum2, des_key1, des_key2, des_key3, xor_seed);
	
	packet3 = DNAS::encrypt3(packet2, 0xc8, 0x20, des_key1, des_key2, des_key3, xor_seed);
	packet4 = DNAS::encrypt3(packet3, 0x28, 0x120, des_key4, des_key5, des_key6, xor_seed2);
	
	// Debug
	/*
	debugPacket("packet1", packet1);
	debugCheckSum(chksum1, chksum2);
	debugDesKeys("des_key[1][2][3]", des_key1, des_key2, des_key3);
	debugXorSeed("xor_seed", xor_seed);
	debugDesKeys("des_key[4][5][6]", des_key4, des_key5, des_key6);
	debugXorSeed("xor_seed2", xor_seed2);
	debugPacket("packet2", packet2);
	debugPacket("packet3", packet3);
	debugPacket("packet4", packet4);
	*/
}

void DNASBypass::Client::debugFileName(std::string& game_id, std::string& query_type, std::string& file_name)
{
	Logger::debug("game_id = " + game_id);
	Logger::debug("query_type = " + query_type);
	Logger::debug("file_name = " + file_name);
}

void DNASBypass::Client::debugCheckSum(const std::vector<unsigned char> chksum1, const std::vector<unsigned char> chksum2)
{
	std::stringstream ss, ss2;
	
	for(int i = 0; i < SHA_DIGEST_LENGTH; i++)
	{
		ss  << std::hex << std::setfill('0') << std::setw(2) << (int)(chksum1[i]);
		ss2 << std::hex << std::setfill('0') << std::setw(2) << (int)(chksum2[i]);
	}
	
	Logger::debug("chksum1 = " + ss.str());
	Logger::debug("chksum2 = " + ss2.str());
}

void DNASBypass::Client::debugDesKeys(const std::string& name, const std::vector<unsigned char>& des_key1,
		const std::vector<unsigned char>& des_key2, const std::vector<unsigned char>& des_key3)
{
	std::stringstream ss, ss2, ss3;
	
	for(int i = 0; i < DES_KEY_SIZE; i++)
	{
		ss  << std::hex << std::setfill('0') << std::setw(2) << (int)(des_key1[i]);
		ss2 << std::hex << std::setfill('0') << std::setw(2) << (int)(des_key2[i]);
		ss3 << std::hex << std::setfill('0') << std::setw(2) << (int)(des_key3[i]);
	}
	
	Logger::debug(name + " = { " + ss.str() + ", " + ss2.str() + ", " + ss3.str() + " }");
}

void DNASBypass::Client::debugXorSeed(const std::string& name, const std::vector<unsigned char>& xor_seed)
{
	std::stringstream ss;
	
	for(int i = 0; i < XOR_KEY_SIZE; i++)
	{
		ss  << std::hex << std::setfill('0') << std::setw(2) << (int)(xor_seed[i]);
	}
	
	Logger::debug(name + " = " + ss.str());
}

void DNASBypass::Client::debugPacket(const std::string& name, const std::vector<unsigned char>& packet)
{
	std::stringstream ss;
	
	for(int i = 0; i < packet.size(); i++)
	{
		ss  << std::hex << std::setfill('0') << std::setw(2) << (int)(packet[i]);
	}
	
	Logger::debug(name + " = " + ss.str());
}

